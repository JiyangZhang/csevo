\section{Use Cases}
\label{sec:use:cases}

As we saw in the previous section, \methodologies are used to set up
experiments and obtain an appropriate dataset for the evaluation.
However, \methodologies do \emph{not} describe the envisioned use of a
model.  Prior work focused on \methodologies, but we argue that
proposed models should be described in terms of \emph{use cases},
i.e., how will the developers use the models eventually.  Once a use
case is chosen, an appropriate \methodology can be selected to
evaluate the model.

% when a model might (not) be used.  Prior work focused on
%\methodologies, but we argue that models should on \emph{use cases}.

In this section, we define three use cases.  The first two use cases
are ``extracted'' from prior work (described in the previous section).
Namely, we reasoned about the evaluation \methodologies that were used
and tried to link it to (somewhat) practical use cases.  The third use
case that we describe is inspired by our own development and can be
evaluated using the \evoaware \methodology.  Note that we do not try
to provide an exhaustive list of use cases, but rather to start off
this important distinction between a use case and an evaluation
\methodology.  We will introduce the use cases via examples.

\Fix{After reading this section: I like (C) and I buy the arguments, but first reading (A) and (B) is quite confusing to me.}

% in what ways developers might end up using
%code summarization models.  We also discuss what methodology is the
%most appropriate to be used to obtain a dataset for evaluating models
%in each use case.  Note that our goal is not to provide an exhaustive
%list of use cases, but to highlight that the use cases should play an
%important role when choosing the evaluation methodology and reporting
%the findings in research papers.

\subsection{In-Project Batch Use Case}

Consider Alice, a developer at a large software company.  Alice has
been developing several features in her project over extended period
of time (since \atimep), but she had no chance to write comments for
all her code.  At one point (\atime), she decided it was time to
document methods without comments.  
\Fix{Doesn't the mixed methodology require also some training data 
within the current project?}
She wants to use an ML model that
can automatically generate comments.  Alice decides to train a model
using already existing \examples (i.e., existing method and comment
pairs) in her code and \examples (available at time \atime) from
several projects on GitHub.  We call this \emph{\ipmode batch use
  case}, because Alice trains a new model every time she wants to use
the model, and she applies it to several methods.  This use case can
be evaluated using the \mixedproj \methodology.

Prior work that used the \mixedproj \methodology
(Table~\ref{table:prior-work}) could fit under this use case, but only
if we assume that some methods have not been documented for very long
time, i.e., $\atime - \atimep = \infty$.
\Fix{Why? Isn't it always feasible to apply this methodology at any point when you need to generate one? Or does the infinity refer to time here?s}
%% \JiyangComment{I think this use case is not 100 percent
%%   consistent with what prior work do. Because you mention at time $t$
%%   Alice want to train the model so that the model can not be trained
%%   using the future data. However, the prior work does not consider
%%   time, they only use the data available at time t and then split.
%%   Should we add that without considering time, prior work is
%%   incorrect?}
% Milos: Note that examples that she wants to document are included
% *before* $t$ (and potentially long time before $t$).

\subsection{Cross-Project Batch Use Case}

In this case, we assume that Alice works on a project (since \atimep)
without writing any documentation for her code.
%
At some point (\atime), Alice decides to document all her methods.
Again, she wants to use an ML model to help her get the task done.
Since Alice does not have any comments in her code, she decides to
only train on projects available on GitHub (at time \atime).  She uses
all \examples (i.e., pairs of methods and comments) in the training
and sets a couple of projects aside for validation.
%
Once the model is trained, she uses it to generate comments for all
the methods that she has.  We call this \emph{\pmode batch use case},
because Alice trains a new model at a specific time point and applies
it to all the methods she has.  (Note that once she integrates the
comments that she likes, she can use them in the future, which matches
\ipmode batch use case, or potentially she could decide to ignore
those comments and always generates new comments, but this is highly
unlikely.)  This use case can be evaluated using the \crossproj
\methodology.

Prior work that used \crossproj (Table~\ref{table:prior-work}) could
fit under this use case, under the assumption that the comment has not
been documented for very long time, i.e., $\atime - \atimep = \infty$.
\Fix{Same question as above: I don't see the case for infinity. PN: how about $\atime - \atimep \rightarrow \infty$}

%% \JiyangComment{Same question here, Alice also considers time when
%%   training the model. It is possible that prior work use the new
%%   project say created in 2019 to train and test in project that is
%%   created in 2012.}

\subsection{Continuous Use Case}

In this case, Alice writes documentation for each method around the
same time as the method itself.  For example, Alice might integrate a
model for comment generation into her IDE that would suggest comments
once Alice indicates that a method is complete.  (Updating and
maintaining comments as code
evolves~\cite{PanthaplackelETAL20CommentUpdate} is an important topic,
but orthogonal to our work.)  Before using the model at \atime, Alice
would have to train the model on the data available in her project and
other projects at \atimep.  She can keep using the same model for as
long as she wishes (i.e., $\atime-\atimep$ can be arbitrary large).
We call this \emph{\cmode}, because the only data that can be used to
train the model is the data from past.  This use case can be evaluated
using the \evoaware \methodology.

The model should be retrained once in a while, e.g., when a new Java
version is introduced that adds new syntax into the language and
developers start adopting the syntax.  Finding an appropriate
frequency at which to retrain the model is left for future work.
